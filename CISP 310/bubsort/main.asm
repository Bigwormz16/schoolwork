;=====================================================================
;			FIBONACCI PROGRAM
;	DESCRIPTION:
;	CALCULATES FIBONACCI SEQUENCE USING UP TO 72
;	DIGITS, ALERTS UPON EXCEEDING 72 DIGITS
;=====================================================================

	DOSSEG
	.MODEL  LARGE,BASIC
							;PROCEDURES TO
	EXTRN	NEWLINE:FAR		;DISPLAY NEWLINE CHARACTER
	EXTRN	PUTDEC$:FAR		;DISPLAY 16-BIT DECIMAL INTEGER
	EXTRN	PUTSTRNG:FAR	;DISPLAY CHARACTER STRING
	EXTRN	PAUSE:FAR		;DISPLAY CHARACTER STRING
	EXTRN	RANDOM:FAR
	EXTRN	CLEAR:FAR
	
;===================================================================
;
; S T A C K   S E G M E N T   D E F I N I T I O N
;
	.STACK  256

;===================================================================
;
; C O N S T A N T   S E G M E N T   D E F I N I T I O N
;
.CODE
.DATA
HEADER		DB	'--BUBBLESORTER--';16
UNSORT		DB	'UNSORTED ARRAY: ';16
SORT1		DB	'METHOD 1 SORT:  '
SORT2		DB	'METHOD 2 SORT:  '

STATH		DB	'STATISTICS:  ';13
STATC		DB	'COMPARISONS: ';13
STATSW		DB	'SWAPS:       '
STATP		DB	'PASSES:      '

;DEBUG		DB	'EXECUTED PAST THIS LINE'	;23 CHARS
PAUMSG		DB	'PRESS ANY KEY TO CONTINUE ... '
NAME_IR		DB	'PROGRAM BY IAN ROSNER';21
;===============================================================
;
; D A T A   S E G M E N T   D E F I N I T I O N
;
LOWER		DW	1
UPPER		DW	100
SWAPF		DW	0	;SWAP FLAG
ARR			DB	100 DUP (0)
ARR2		DB	100	DUP	(0)
;COUNTERS
SWAPCT		DW	0
COMPCT		DW	0
PASSCT		DW	0
;===============================================================
;
; C O D E   S E G M E N T   D E F I N I T I O N
;
	.CODE
	;ASSUME DS:NOTHING,ES:DGROUP
STARTUP:
	MOV		AX,DGROUP		;SET ES TO POINT TO DATA SEG
	MOV		ES,AX
	MOV		DS,AX
	
	LEA		DI,HEADER
		MOV		CX,16
		CALL	PUTSTRNG
		CALL	NEWLINE

MAIN:
	;FILL ARRAY WITH RANDOM NUMBERS
	;WITH RANGE OF 1 TO 100
	MOV		DI,0

	FILL:
		PUSH	LOWER
		PUSH	UPPER
		CALL	RANDOM
		MOV		ARR[DI],AL
		MOV		ARR2[DI],AL

	INC		DI
	CMP		DI,100
	JL		FILL

	LEA		DI,UNSORT
	CALL	PUTSTRNG
	CALL	NEWLINE
	CALL	PRINTARRAY

	LEA		DI,PAUMSG
	MOV		CX,30
	CALL	PAUSE
	CALL	CLEAR

M1_:
	;SORT METHOD 1
	;DECIDES WHEN SORTED [NO BRUTE FORCE]
	;WORST CASE = N^2, 100*100 = 10,000
	MOV		CX,0
	M1OUTER:
		MOV		DI,0
		MOV		SWAPF,0
		INC		PASSCT		;PASS
		M1INNER:
			MOV		BL,ARR[DI+1]
			MOV		BH,ARR[DI]
			INC		COMPCT		;COMPARISON
			.IF BH > BL
				;SWAP VALUES -- BX HOLDS TEMP VALUE
				MOV		ARR[DI+1],BH
				MOV		ARR[DI],BL
				MOV		SWAPF,1		;SET SWAP FLAG
				INC		SWAPCT
			.ENDIF
			
			INC		DI
			CMP		DI,98		;0-99 CELLS, CHECKS 98+1
			JLE		M1INNER		;(99+1 NOT IN ARRAY)
			;OTHERWISE...
			INC		CX
			.IF (SWAPF == 0) || (CX >= 100)
				;WE ARE DONE
				JMP M1FIN
			.ENDIF

	JMP M1OUTER

M1FIN:
	;CHECK OUR RESULTS
	LEA		DI,SORT1
	MOV		CX,16
	CALL	PUTSTRNG
	CALL	NEWLINE
	
	CALL	PRINTARRAY
	CALL	STATREPORT

	LEA		DI,PAUMSG
	MOV		CX,30
	CALL	PAUSE
	CALL	NEWLINE

	;RESET STATS FOR SECOND METHOD
	MOV		SWAPCT,0
	MOV		PASSCT,0
	MOV		COMPCT,0

	;REFILL ARR1
	MOV		DI,0
REFILL:
	MOV		AL,ARR2[DI]
	MOV		ARR[DI],AL
	INC		DI
	CMP		DI,99
	JLE		REFILL
	
M2_:
	;SORT METHOD 2
	;ASCENDING & DESCENDING SORT
	MOV		AX,98;CONTAINS UPPER LIMIT
	MOV		CX,0 ;CONTAINS LOWER LIMIT
	M2OUTER:
		;ASCENDING SORT
		MOV		SWAPF,0
		MOV		DI,0
		INC		PASSCT
			M2UP:
				MOV		BL,ARR[DI+1]
				MOV		BH,ARR[DI]
				INC		COMPCT
				.IF BH > BL
					;SWAP VALUES -- BX HOLDS TEMP VALUE
					MOV		ARR[DI+1],BH
					MOV		ARR[DI],BL
					MOV		SWAPF,1		;SET SWAP FLAG
					INC		SWAPCT
				.ENDIF

				INC		DI	
				CMP		DI,AX
				JLE		M2UP
				DEC		AX
				;DID WE SWAP ANYTHING?
					.IF SWAPF == 0
						JMP M2FIN
					.ENDIF
				;AFTER THAT, DO A DOWNWARD PASS
				INC		PASSCT		;NEXT PASS
				MOV		SWAPF,0		;RESET FLAG
				;WE KNOW THAT THE LAST VALUE IS
				;NOW IN PLACE -- DECREMENT DI
				DEC		DI
			M2DOWN:
				MOV		BL,ARR[DI-1]
				MOV		BH,ARR[DI]
				INC		COMPCT
				.IF BH < BL
					;SWAP VALUES -- BX HOLDS TEMP VALUE
					MOV		ARR[DI-1],BH
					MOV		ARR[DI],BL
					MOV		SWAPF,1		;SET SWAP FLAG
					INC		SWAPCT
				.ENDIF
				DEC		DI
				CMP		DI,CX		;IF DI > LOWER LIMIT
				JG		M2DOWN
				INC		CX		;BOTTOM ELEMENTS ARE IN PLACE
				;SWAP?
				.IF SWAPF == 0
						JMP M2FIN
				.ENDIF

				;OTHERWISE, CONTINUE ON TO
				;UPWARD PASS
				JMP		M2OUTER


M2FIN:
	LEA		DI,SORT2
	MOV		CX,16
	CALL	PUTSTRNG
	CALL	NEWLINE

	CALL	PRINTARRAY
	CALL	STATREPORT

DONE:
	CALL	NEWLINE
	CALL	NEWLINE
	LEA		DI,NAME_IR
	MOV		CX,21
	CALL	PUTSTRNG
	CALL	NEWLINE
	LEA		DI,PAUMSG
	MOV		CX,30
	CALL 	PAUSE

	.EXIT


PRINTARRAY		PROC		NEAR PUBLIC USES AX BX DI
	;PRINTS ARR
	;BL IS LINE ELEMENT COUNTER
	MOV		DI,0
	MOV		BL,0
	MOV		BH,-1	;PUTDEC FORMATTING
	PRINTLOOP:
		MOV		AL,ARR[DI]
		CALL	PUTDEC$
		INC		DI
		INC		BL
	
	.IF BL == 10
		;CALL	NEWLINE
		CALL	NEWLINE
		MOV		BL,0
	.ENDIF

	CMP		DI,99
	JLE		PRINTLOOP

	RET
PRINTARRAY		ENDP

STATREPORT		PROC		NEAR PUBLIC USES AX CX DI
	;STATISTICS REPORT
	MOV		CX,13
	MOV		BH,-1

	LEA		DI,STATH
	CALL	PUTSTRNG
	CALL	NEWLINE

	LEA		DI,STATC
	CALL	PUTSTRNG
	MOV		AX,COMPCT
	CALL	PUTDEC$
	CALL	NEWLINE

	LEA		DI,STATSW
	CALL	PUTSTRNG
	MOV		AX,SWAPCT
	CALL	PUTDEC$
	CALL	NEWLINE

	LEA		DI,STATP
	CALL	PUTSTRNG
	MOV		AX,PASSCT
	CALL	PUTDEC$
	CALL	NEWLINE

	RET
STATREPORT ENDP
END STARTUP
